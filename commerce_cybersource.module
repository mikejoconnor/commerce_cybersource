<?php

/**
 * @file
 * Implements CyberSource payment services for use in Drupal Commerce.
 */

// CyberSource transaction mode definitions:
define('CYBERSOURCE_TXN_MODE_PRODUCTION', 'production');
define('CYBERSOURCE_TXN_MODE_TEST', 'test');


/**
 * Implements hook_menu().
 */
function commerce_cybersource_menu() {
  $items = array();

  // Add a menu item for capturing authorizations.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/cybersource-soap-capture'] = array(
    'title' => 'Capture',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_cybersource_soap_capture_form', 3, 5),
    'access callback' => 'commerce_cybersource_soap_capture_access',
    'access arguments' => array(3, 5),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'weight' => 2,
    'file' => 'includes/commerce_cybersource.admin.inc',
  );

  return $items;
}

/**
 * Determines access to the prior authorization capture form for CyberSource
 *   SOAP credit card transactions.
 *
 * @param $order
 *   The order the transaction is on.
 * @param $transaction
 *   The payment transaction object to be captured.
 *
 * @return
 *   TRUE or FALSE indicating capture access.
 */
function commerce_cybersource_soap_capture_access($order, $transaction) {
  // Return FALSE if the transaction isn't for CyberSource SOAP or isn't
  // awaiting capture.
  if ($transaction->payment_method != 'cybersource_soap_cc' || strpos($transaction->remote_status, COMMERCE_CREDIT_AUTH_ONLY) !== 0) {
    return FALSE;
  }

  // Allow access if the user can update payments on this order.
  return commerce_payment_transaction_access('update', $order, $transaction);
}

/**
 * Implements hook_commerce_payment_method_info().
 */
function commerce_cybersource_commerce_payment_method_info() {
  $payment_methods = array();

  $payment_methods['cybersource_soap_cc'] = array(
    'base' => 'commerce_cybersource_soap_cc',
    'title' => t('CyberSource SOAP API - CC'),
    'short_title' => t('CyberSource CC'),
    'display_title' => t('Credit card'),
    'description' => t('Integrates the CyberSource SOAP API Toolkit for card not present CC transactions.'),
  );

  return $payment_methods;
}

/**
 * Payment method callback: settings form.
 */
function commerce_cybersource_soap_cc_settings_form($settings = NULL) {
  $form = array();

  // Merge default settings into the stored settings array.
  $settings = (array) $settings + array(
    'merchant_id' => '',
    'transaction_key' => '',
    'transaction_mode' => CYBERSOURCE_TXN_MODE_TEST,
    'transaction_type' => COMMERCE_CREDIT_AUTH_CAPTURE,
    'log' => array('request' => '0', 'response' => '0'),
  );

  $form['merchant_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Merchant ID'),
    '#description' => t('This is the merchant ID you use to login to the CyberSource business center.'),
    '#default_value' => $settings['merchant_id'],
    '#required' => TRUE,
  );
  $form['transaction_key'] = array(
    '#type' => 'textarea',
    '#title' => t('Transaction Key'),
    '#description' => t('Enter a key generated for the SOAP Toolkit API under Account Management > Transaction Security Keys in the business center.'),
    '#default_value' => $settings['transaction_key'],
    '#required' => TRUE,
  );
  $form['transaction_mode'] = array(
    '#type' => 'radios',
    '#title' => t('Transaction mode'),
    '#description' => t('Adjust to live transactions when you are ready to start processing real payments.'),
    '#options' => array(
      CYBERSOURCE_TXN_MODE_PRODUCTION => t('Live transactions in the production environment'),
      CYBERSOURCE_TXN_MODE_TEST => t('Test transactions in the test environment'),
    ),
    '#default_value' => $settings['transaction_mode'],
  );
  $form['transaction_type'] = array(
    '#type' => 'radios',
    '#title' => t('Default credit card transaction type'),
    '#description' => t('The default will be used to process transactions during checkout.'),
    '#options' => array(
      COMMERCE_CREDIT_AUTH_CAPTURE => t('Authorization and capture'),
      COMMERCE_CREDIT_AUTH_ONLY => t('Authorization only (requires manual or automated capture after checkout)'),
    ),
    '#default_value' => $settings['transaction_type'],
  );
  $form['log'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Log the following messages for debugging'),
    '#options' => array(
      'request' => t('API request messages'),
      'response' => t('API response messages'),
    ),
    '#default_value' => $settings['log'],
  );

  return $form;
}

/**
 * Payment method callback: checkout form.
 */
function commerce_cybersource_soap_cc_submit_form($payment_method, $pane_values, $checkout_pane, $order) {
  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');
  return commerce_payment_credit_card_form(array('code' => ''));
}

/**
 * Payment method callback: checkout form validation.
 */
function commerce_cybersource_soap_cc_submit_form_validate($payment_method, $pane_form, $pane_values, $order, $form_parents = array()) {
  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');

  // Validate the credit card fields.
  $settings = array(
    'form_parents' => array_merge($form_parents, array('credit_card')),
  );

  if (!commerce_payment_credit_card_validate($pane_values['credit_card'], $settings)) {
    return FALSE;
  }
}

/**
 * Payment method callback: checkout form submission.
 */
function commerce_cybersource_soap_cc_submit_form_submit($payment_method, $pane_form, $pane_values, $order, $charge) {
  // Create and populate the request object.
  $request = (object) array(
    'merchantReferenceCode' => t('Order @number', array('@number' => $order->order_number)),
  );

  // Request an authorization that may also be captured this request. Whether
  // the default transaction type is authorization only or authorization plus
  // capture, the authorization must first happen in its own API request.
  $request->ccAuthService = (object) array(
    'run' => 'true',
  );

  // Add the billing information.
  // TODO: Populate with data from the address field.
  $request->billTo = (object) array(
    'firstName' => 'Joe',
    'lastName' => 'Buyer',
    'street1' => '500 Wombat Way',
    'city' => 'Louisville',
    'state' => 'KY',
    'postalCode' => '40203',
    'country' => 'US',
    'email' => empty($order->mail) ? 'null@cybersource.com' : $order->mail,
    'ipAddress' => ip_address(),
  );

  // Add the credit card details.
  $request->card = (object) array(
    'accountNumber' => $pane_values['credit_card']['number'],
    'expirationMonth' => $pane_values['credit_card']['exp_month'],
    'expirationYear' => $pane_values['credit_card']['exp_year'],
  );

  // Add the CVV data if included.
  if (isset($pane_values['credit_card']['code'])) {
    $request->card->cvNumber = $pane_values['credit_card']['code'];
  }

  // Add purchase total information.
  $request->purchaseTotals = (object) array(
    'currency' => $charge['currency_code'],
    'grandTotalAmount' => $charge['amount'],
  );

  /**
   * TODO: Expand later to include line item based info instead.
  $item0 = new stdClass();
  $item0->unitPrice = "12.34";
  $item0->quantity = "2";
  $item0->id = "0";

  $item1 = new stdClass();
  $item1->unitPrice = "56.78";
  $item1->id = "1";

  $request->item = array($item0, $item1);
   */

  // Add the capture directive if specified in the payment method settings.
  if ($payment_method['settings']['transaction_type'] == COMMERCE_CREDIT_AUTH_CAPTURE) {
    $request->ccCaptureService = (object) array(
      'run' => 'true',
    );
  }

  if ($response = commerce_cybersource_soap_api_request($payment_method, $request)) {
    // Prepare a transaction object to log the API response.
    $transaction = commerce_payment_transaction_new('cybersource_soap_cc', $order->order_id);
    $transaction->instance_id = $payment_method['instance_id'];
    $transaction->remote_id = $response->requestID;
    $transaction->amount = $charge['amount'];
    $transaction->currency_code = $charge['currency_code'];
    $transaction->payload[REQUEST_TIME] = $response;

    // If we didn't get an approval response code...
    if ($response->ccAuthReply->reasonCode != 100) {
      // Create a failed transaction with the error message.
      $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
    }
    else {
      // Otherwise if we also captured successfully, mark this as a success.
      if ($payment_method['settings']['transaction_type'] == COMMERCE_CREDIT_AUTH_CAPTURE &&
        $response->ccCaptureReply->reasonCode == 100) {
        $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
        $transaction->remote_status = COMMERCE_CREDIT_AUTH_CAPTURE;
      }
      else {
        // Or leave it pending.
        $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;

        // Store the transaction type with the timestamp so the request token can be
        // reliably retrieved later for capturing.
        $transaction->remote_status = COMMERCE_CREDIT_AUTH_ONLY . ':' . REQUEST_TIME;
      }
    }

    // Build a meaningful response message.
    $message = array(
      '<b>' . ($payment_method['settings']['transaction_type'] == COMMERCE_CREDIT_AUTH_ONLY ? t('Credit Card Authorization') : t('Credit Card Authorization and Capture')) . '</b>',
      '<b>' . t('@decision:', array('@decision' => $response->decision)) . '</b> ' . commerce_cybersource_reason_message($response->reasonCode),
    );

    // Add an AVS response if returned.
    if (!empty($response->ccAuthReply->avsCode)) {
      $message[] = '<b>' . t('AVS response:') . '</b> ' . commerce_cybersource_avs_response($response->ccAuthReply->avsCode);
    }

    // Add a CVV response if returned.
    if (!empty($response->ccAuthReply->cvCode)) {
      $message[] = '<b>' . t('CVN response:') . '</b> ' . commerce_cybersource_avs_response($response->ccAuthReply->cvCode);
    }

    $transaction->message = implode('<br />', $message);

    // Save the transaction information.
    commerce_payment_transaction_save($transaction);

    // If the payment failed, display an error and rebuild the form.
    if ($response->ccAuthReply->reasonCode != 100) {
      drupal_set_message(t('We received the following error processing your card: @reason', array('@reason' => commerce_cybersource_reason_message($response->ccAuthReply->reasonCode))), 'error');
      drupal_set_message('Please enter you information again or try a different card.', 'error');
      return FALSE;
    }
  }
  else {
    drupal_set_message(t('We encountered an error contacting our payment processor. Please try submitting your payment again.'), 'error');
    return FALSE;
  }
}

/**
 * Submits a prior authorization capture request.
 */
function commerce_cybersource_soap_capture($order, $transaction, $amount) {
  // Load the payment method instance used to create the authorization.
  $payment_method = commerce_payment_method_instance_load($transaction->instance_id);

  // Extract the timestamp used to retrieve the order request token from the
  // remote status value.
  list($status, $timestamp) = explode(':', $transaction->remote_status);

  // Fail now if now timestamp was found or the payload is missing.
  if (empty($timestamp) || empty($transaction->payload[$timestamp])) {
    return FALSE;
  }

  // Create and populate the request object.
  $request = (object) array(
    'merchantReferenceCode' => t('Order @number', array('@number' => $order->order_number)),
    'orderRequestToken' => $transaction->payload[$timestamp]->requestToken,
  );

  // Add purchase total information.
  $request->purchaseTotals = (object) array(
    'currency' => $transaction->currency_code,
    'grandTotalAmount' => $amount,
  );

  // Add the capture service information.
  $request->ccCaptureService = (object) array(
    'run' => 'true',
    'authRequestID' => $transaction->remote_id,
  );

  if ($response = commerce_cybersource_soap_api_request($payment_method, $request)) {
    // Add the response to the payload.
    $transaction->payload[REQUEST_TIME] = $response;

    if ($response->ccCaptureReply->reasonCode == 100) {
      // Update the amount in case it changed between authorization and capture.
      $transaction->amount = $response->ccCaptureReply->amount;

      // Update the transaction status and remote status.
      $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
      $transaction->remote_status = COMMERCE_CREDIT_PRIOR_AUTH_CAPTURE . ':' . REQUEST_TIME;
    }

    commerce_payment_transaction_save($transaction);

    return $response;
  }
  else {
    return FALSE;
  }
}

/**
 * Submits an API request through the CyberSource SOAP API Toolkit.
 *
 * @param $payment_method
 *   The payment method instance array associated with this API request.
 * @param $request
 *   The request object containing the parameters of the requested services.
 *
 * @return
 *   The response object from the API with properties pertinent to the requested
 *     services.
 */
function commerce_cybersource_soap_api_request($payment_method, $request) {
  // Get the API endpoint URL for the method's transaction mode.
  $url = commerce_cybersource_soap_wsdl_url($payment_method['settings']['transaction_mode']);

  // Add the merchant ID to the request object.
	$request->merchantID = $payment_method['settings']['merchant_id'];

  // Add information on PHP for troubleshooting purposes.
	$request->clientLibrary = 'PHP';
  $request->clientLibraryVersion = phpversion();
  $request->clientEnvironment = php_uname();

  // Log the request if specified.
  if ($payment_method['settings']['log']['request'] == 'request') {
    // Get our clone on to avoid messing up the legit data.
    $log_request = clone($request);

    // Mask the credit card number and CVV.
    if (!empty($log_request->card)) {
      $log_request->card = clone($log_request->card);

      $log_request->card->accountNumber = str_repeat('X', strlen($log_request->card->accountNumber) - 4) . substr($log_request->card->accountNumber, -4);

      if (!empty($log_request->card->cavv)) {
        $log_request->card->cavv = str_repeat('X', strlen($log_request->card->cavv));
      }
    }

    watchdog('commerce_cybersource', 'CyberSource SOAP request to @url: !request', array('@url' => $url, '!request' => '<pre>' . check_plain(print_r($log_request, TRUE)) . '</pre>'), WATCHDOG_DEBUG);
  }

  // Attempt the SOAP request and log the exception on failure.
  try {
    $soapClient = new CommerceCyberSourceSoapClient($url, array(), $request->merchantID, $payment_method['settings']['transaction_key']);
    $response = $soapClient->runTransaction($request);
  }
  catch (SoapFault $exception) {
    watchdog('commerce_cybersource', 'SoapFault: !exception', array('!exception' => '<pre>' . print_r($exception, TRUE) . '</pre>'), WATCHDOG_ERROR);
    return FALSE;
  }

  // Log the response if specified.
  if ($payment_method['settings']['log']['response'] == 'response') {
    watchdog('commerce_cybersource', 'CyberSource SOAP response: !request', array('!request' => '<pre>' . check_plain(print_r($response, TRUE)) . '</pre>', WATCHDOG_DEBUG));
  }

  return $response;
}

/**
 * Returns the URL to the CyberSource WSDL determined by transaction mode.
 *
 * @param $transaction_mode
 *   The transaction mode that relates to the production or test server.
 *
 * @return
 *   The URL to use to submit requests to the CyberSource SOAP server.
 */
function commerce_cybersource_soap_wsdl_url($transaction_mode) {
  switch ($transaction_mode) {
    case CYBERSOURCE_TXN_MODE_PRODUCTION:
      return 'https://ics2ws.ic3.com/commerce/1.x/transactionProcessor/CyberSourceTransaction_1.55.wsdl';
    case CYBERSOURCE_TXN_MODE_TEST:
      return 'https://ics2wstest.ic3.com/commerce/1.x/transactionProcessor/CyberSourceTransaction_1.55.wsdl';
  }
}

/**
 * Returns the message text for a credit card service reason code.
 */
function commerce_cybersource_reason_message($code) {
  switch ($code) {
    case 100:
      return t('Successful transaction.');
    case 101:
      return t('The request is missing one or more required fields.');
    case 102:
      return t('One or more fields in the request contains invalid data.');
    case 110:
      return t('Only a partial amount was approved.');
    case 150:
      return t('Error: General system failure.');
    case 151:
      return t('Error: The request was received but there was a server timeout. This error does not include timeouts between the client and the server.');
    case 152:
      return t('Error: The request was received, but a service did not finish running in time.');
    case 200:
      return t('The authorization request was approved by the issuing bank but declined by CyberSource because it did not pass the Address Verification Service (AVS) check.');
    case 201:
      return t('The issuing bank has questions about the request. You do not receive an authorization code programmatically, but you might receive one verbally by calling the processor.');
    case 202:
      return t('Expired card.');
    case 203:
      return t('General decline of the card. No other information provided by the issuing bank.');
    case 204:
      return t('Insufficient funds in the account.');
    case 205:
      return t('Stolen or lost card.');
    case 207:
      return t('Issuing bank unavailable.');
    case 208:
      return t('Inactive card or card not authorized for card-not-present transactions.');
    case 209:
      return t('American Express Card Identification Digits (CID) did not match.');
    case 210:
      return t('The card has reached the credit limit.');
    case 211:
      return t('Invalid CVN.');
    case 221:
      return t('The customer matched an entry on the processor’s negative file.');
    case 230:
      return t('The authorization request was approved by the issuing bank but declined by CyberSource because it did not pass the CVN check.');
    case 231:
      return t('Invalid account number.');
    case 232:
      return t('The card type is not accepted by the payment processor.');
    case 233:
      return t('General decline by the processor.');
    case 234:
      return t('There is a problem with your CyberSource merchant configuration.');
    case 235:
      return t('The requested amount exceeds the originally authorized amount.');
    case 236:
      return t('Processor failure.');
    case 237:
      return t('The authorization has already been reversed.');
    case 238:
      return t('The authorization has already been captured.');
    case 239:
      return t('The requested transaction amount must match the previous transaction amount.');
    case 240:
      return t('The card type sent is invalid or does not correlate with the credit card number.');
    case 241:
      return t('The request ID is invalid.');
    case 242:
      return t('You requested a capture, but there is no corresponding, unused authorization record.');
    case 243:
      return t('The transaction has already been settled or reversed.');
    case 246:
      return t('The capture or credit is not voidable because the capture or credit information has already been submitted to your processor or you requested a void for a type of transaction that cannot be voided.');
    case 247:
      return t('You requested a credit for a capture that was previously voided.');
    case 250:
      return t('Error: The request was received, but there was a timeout at the payment processor.');
  }

  return '-';
}

/**
 * Returns the message text for an AVS response code.
 */
function commerce_cybersource_avs_response($code) {
  switch ($code) {
    case'A':
      return t('Partial match: Street address matches, but 5-digit and 9-digit postal codes do not match.');
    case 'B':
      return t('Partial match: Street address matches, but postal code is not verified.');
    case 'C':
      return t('No match: Street address and postal code do not match.');
    case 'D':
    case 'M':
      return t('Match: Street address and postal code match.');
    case 'E':
      return t('Invalid: AVS data is invalid or AVS is not allowed for this card type.');
    case 'F':
      return t("Partial match: Card member's name does not match, but billing postal code matches.");
    case 'G':
      return t('Not supported: Non-U.S. issuing bank does not support AVS.');
    case 'H':
      return t('Partial match: Card member’s name does not match, but street address and postal code match.');
    case 'I':
      return t('No match: Address not verified.');
    case 'K':
      return t("Partial match: Card member's name matches, but billing address and billing postal code do not match.");
    case 'L':
      return t("Partial match: Card member's name and billing postal code match, but billing address does not match.");
    case 'N':
      return t("No match: Street address and postal code do not match or card member's name, street address and postal code do not match.");
    case 'O':
      return t("Partial match: Card member's name and billing address match, but billing postal code does not match.");
    case 'P':
      return t('Partial match: Postal code matches, but street address not verified.');
    case 'R':
      return t('System unavailable.');
    case 'S':
      return t('Not supported: U.S.-issuing bank does not support AVS.');
    case 'T':
      return t("Partial match: Card member's name does not match, but street address matches.");
    case 'U':
      return t('System unavailable: Address information unavailable from the bank.');
    case 'V':
      return t("Match: Card member's name, billing address, and billing postal code match.");
    case 'W':
      return t('Partial match: Street address does not match, but 9-digit postal code matches.');
    case 'X':
      return t('Match: Street address and 9-digit postal code match.');
    case 'Y':
      return t('Match: Street address and 5-digit postal code match.');
    case 'Z':
      return t('Partial match: Street address does not match, but 5-digit postal code matches.');
    case '1':
      return t('Not supported: AVS is not supported for this processor or card type.');
    case '2':
      return t('Invalid: The processor returned an unrecognized value for the AVS response.');
  }

  return '-';
}

/**
 * Returns the message text for a CVV match.
 */
function commerce_cybersource_cvn_response($code) {
  switch ($code) {
    case 'D':
      return t('The transaction was determined to be suspicious by the issuing bank.');
    case 'I':
      return t("The CVN failed the processor's data validation check.");
    case 'M':
      return t('The CVN matched.');
    case 'N':
      return t('The CVN did not match.');
    case 'P':
      return t('The CVN was not processed by the processor for an unspecified reason.');
    case 'S':
      return t('The CVN is on the card but was not included in the request.');
    case 'U':
      return t('Card verification is not supported by the issuing bank.');
    case 'X':
      return t('Card verification is not supported by the card association.');
    case '1':
      return t('Card verification is not supported for this processor or card type.');
    case '2':
      return t('An unrecognized result code was returned by the processor for the card verification response.');
    case '3':
      return t('No result code was returned by the processor.');
  }

  return '-';
}
