<?php

/**
 * @file
 * Implements CyberSource payment services for use in Drupal Commerce.
 */

// CyberSource transaction mode definitions:
define('CYBERSOURCE_TXN_MODE_PRODUCTION', 'production');
define('CYBERSOURCE_TXN_MODE_TEST', 'test');


/**
 * Implements hook_menu().
 */
function commerce_cybersource_menu() {
  $items = array();

  // Add a menu item for capturing authorizations.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/cybersource-soap-capture'] = array(
    'title' => 'Capture',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_cybersource_soap_capture_form', 3, 5),
    'access callback' => 'commerce_cybersource_soap_capture_access',
    'access arguments' => array(3, 5),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'weight' => 2,
    'file' => 'includes/commerce_cybersource.admin.inc',
  );

  return $items;
}

/**
 * Determines access to the prior authorization capture form for CyberSource
 *   SOAP credit card transactions.
 *
 * @param $order
 *   The order the transaction is on.
 * @param $transaction
 *   The payment transaction object to be captured.
 *
 * @return
 *   TRUE or FALSE indicating capture access.
 */
function commerce_cybersource_soap_capture_access($order, $transaction) {
  // Return FALSE if the transaction isn't for CyberSource SOAP or isn't
  // awaiting capture.
  if ($transaction->payment_method != 'cybersource_soap_cc' || strpos($transaction->remote_status, COMMERCE_CREDIT_AUTH_ONLY) !== 0) {
    return FALSE;
  }

  // Allow access if the user can update payments on this transaction.
  return commerce_payment_transaction_access('update', $transaction);
}

/**
 * Implements hook_commerce_payment_method_info().
 */
function commerce_cybersource_commerce_payment_method_info() {
  $payment_methods = array();

  $payment_methods['cybersource_soap_cc'] = array(
    'base' => 'commerce_cybersource_soap_cc',
    'title' => t('CyberSource SOAP API - CC'),
    'short_title' => t('CyberSource CC'),
    'display_title' => t('Credit card'),
    'description' => t('Integrates the CyberSource SOAP API Toolkit for card not present CC transactions.'),
  );

  return $payment_methods;
}

/**
 * Returns the default settings for the CyberSource SOAP CC payment method.
 */
function commerce_cybersource_soap_cc_default_settings() {
  return array(
    'merchant_id' => '',
    'transaction_key' => '',
    'transaction_mode' => CYBERSOURCE_TXN_MODE_TEST,
    'credit_card' => array(
      'transaction_type' => COMMERCE_CREDIT_AUTH_CAPTURE,
      'submit_itemized_order' => FALSE,
      'card_types' => array(),
    ),
    'tax' => array(
      'calculate_taxes' => FALSE,
      'nexus' => '',
      'shipping_profile' => '',
      'poo' => array(
        'city' => '',
        'state' => '',
        'postal_code' => '',
        'county' => '',
        'country' => variable_get('site_default_country', ''),
      ),
      'poa' => array(
        'city' => '',
        'state' => '',
        'postal_code' => '',
        'county' => '',
        'country' => variable_get('site_default_country', ''),
      ),
      'origin' => array(
        'city' => '',
        'state' => '',
        'postal_code' => '',
        'county' => '',
        'country' => variable_get('site_default_country', ''),
      ),
      'seller_registration' => '',
    ),
    'log' => array('request' => '0', 'response' => '0'),
  );
}

/**
 * Payment method callback: settings form.
 */
function commerce_cybersource_soap_cc_settings_form($settings = NULL) {
  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');
  $settings += commerce_cybersource_soap_cc_default_settings();

  // Required to get a list of all countries.
  require_once DRUPAL_ROOT . '/includes/locale.inc';

  $form = array();

  $form['merchant_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Merchant ID'),
    '#description' => t('This is the merchant ID you use to login to the CyberSource business center.'),
    '#default_value' => $settings['merchant_id'],
    '#required' => TRUE,
  );
  $form['transaction_key'] = array(
    '#type' => 'textarea',
    '#title' => t('Transaction Key'),
    '#description' => t('Enter a key generated for the SOAP Toolkit API under Account Management > Transaction Security Keys in the business center.'),
    '#default_value' => $settings['transaction_key'],
    '#required' => TRUE,
  );
  $form['transaction_mode'] = array(
    '#type' => 'radios',
    '#title' => t('Transaction mode'),
    '#description' => t('Adjust to live transactions when you are ready to start processing real payments.'),
    '#options' => array(
      CYBERSOURCE_TXN_MODE_PRODUCTION => t('Live transactions in the production environment'),
      CYBERSOURCE_TXN_MODE_TEST => t('Test transactions in the test environment'),
    ),
    '#default_value' => $settings['transaction_mode'],
  );
  $form['log'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Log the following messages for debugging'),
    '#options' => array(
      'request' => t('API request messages'),
      'response' => t('API response messages'),
    ),
    '#default_value' => $settings['log'],
  );

  $form['credit_card'] = array(
    '#type' => 'fieldset',
    '#title' => t('Credit card service settings'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['credit_card']['transaction_type'] = array(
    '#type' => 'radios',
    '#title' => t('Default credit card transaction type'),
    '#description' => t('The default will be used to process transactions during checkout.'),
    '#options' => array(
      COMMERCE_CREDIT_AUTH_CAPTURE => t('Authorization and capture'),
      COMMERCE_CREDIT_AUTH_ONLY => t('Authorization only (requires manual or automated capture after checkout)'),
    ),
    '#default_value' => $settings['credit_card']['transaction_type'],
  );
  $form['credit_card']['submit_itemized_order'] = array(
    '#type' => 'checkbox',
    '#title' => t('Submit itemized orders to CyberSource instead of just sending the grand total to authorize / capture.'),
    '#default_value' => $settings['credit_card']['submit_itemized_order'],
  );
  $form['credit_card']['card_types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Limit accepted credit cards to the following types'),
    '#description' => t('If none are checked, any credit card type will be accepted.'),
    '#options' => commerce_payment_credit_card_types(),
    '#default_value' => $settings['credit_card']['card_types'],
  );

  $form['tax'] = array(
    '#type' => 'fieldset',
    '#title' => t('Tax service settings'),
    '#description' => t('CyberSource offers a tax calculation service through which they will calculate taxes for your orders for a fee per request. If you have enabled this with your account and are willing to pay to calculate taxes for each order, these settings will let you properly use their tax service.'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['tax']['calculate_taxes'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable tax calculation through CyberSource. This occurs during the checkout process when a customer advances to the Review page or when requested by an administrator on the back end.'),
    '#default_value' => $settings['tax']['calculate_taxes'],
  );
  $form['tax']['nexus'] = array(
    '#type' => 'textarea',
    '#title' => t('Nexus'),
    '#description' => t('Enter two-letter abbreviations separated by spaces representing the states or provinces where your business has nexus. This is defined as a place where you have a business address, whether it is for administrative, warehousing, or delivery purposes. Sales taxes in the U.S. and Canada will only be applied when shipping to a customer who resides in a state or province where you have nexus. Leave blank to calculate all applicable taxes for a customer irregardless of where you have nexus.'),
    '#default_value' => $settings['tax']['nexus'],
  );

  // Generate an options list of customer profile reference fields attached to orders.
  $options = array();

  foreach (commerce_info_fields('commerce_customer_profile_reference', 'commerce_order') as $field_name => $field) {
    $options[$field_name] = check_plain($field_name);
  }

  $form['tax']['shipping_profile'] = array(
    '#type' => 'select',
    '#title' => t('Shipping information reference field'),
    '#description' => t("Select a customer profile reference field attached to your order that contains the customer's shipping address."),
    '#options' => $options,
    '#default_value' => $settings['tax']['shipping_profile'],
    '#empty_value' => '',
  );

  $form['tax']['poo'] = array(
    '#type' => 'fieldset',
    '#title' => t('Point of order origin'),
    '#description' => t("This is the place of business where you receive the customer's order."),
  );
  $form['tax']['poo']['city'] = array(
    '#type' => 'textfield',
    '#title' => t('City'),
    '#default_value' => $settings['tax']['poo']['city'],
    '#maxlength' => 50,
  );
  $form['tax']['poo']['state'] = array(
    '#type' => 'textfield',
    '#title' => t('State / Province'),
    '#description' => t('Use the appropriate two-letter abbreviation.'),
    '#default_value' => $settings['tax']['poo']['state'],
    '#maxlength' => 2,
  );
  $form['tax']['poo']['postal_code'] = array(
    '#type' => 'textfield',
    '#title' => t('Postal code'),
    '#default_value' => $settings['tax']['poo']['postal_code'],
    '#maxlength' => 10,
  );
  $form['tax']['poo']['county'] = array(
    '#type' => 'textfield',
    '#title' => t('County'),
    '#default_value' => $settings['tax']['poo']['county'],
    '#maxlength' => 50,
  );
  $form['tax']['poo']['country'] = array(
    '#type' => 'select',
    '#title' => t('Country'),
    '#options' => country_get_list(),
    '#default_value' => $settings['tax']['poo']['country'],
  );

  $form['tax']['poa'] = array(
    '#type' => 'fieldset',
    '#title' => t('Point of order acceptance'),
    '#description' => t("This is the place of business where you accept and approve the customer’s order, thereby becoming contractually obligated to make the sale. This may be the same as your point of order origin."),
  );
  $form['tax']['poa']['city'] = array(
    '#type' => 'textfield',
    '#title' => t('City'),
    '#default_value' => $settings['tax']['poa']['city'],
    '#maxlength' => 50,
  );
  $form['tax']['poa']['state'] = array(
    '#type' => 'textfield',
    '#title' => t('State / Province'),
    '#description' => t('Use the appropriate two-letter abbreviation.'),
    '#default_value' => $settings['tax']['poa']['state'],
    '#maxlength' => 2,
  );
  $form['tax']['poa']['postal_code'] = array(
    '#type' => 'textfield',
    '#title' => t('Postal code'),
    '#default_value' => $settings['tax']['poa']['postal_code'],
    '#maxlength' => 10,
  );
  $form['tax']['poa']['county'] = array(
    '#type' => 'textfield',
    '#title' => t('County'),
    '#default_value' => $settings['tax']['poa']['county'],
    '#maxlength' => 50,
  );
  $form['tax']['poa']['country'] = array(
    '#type' => 'select',
    '#title' => t('Country'),
    '#options' => country_get_list(),
    '#default_value' => $settings['tax']['poa']['country'],
  );

  $form['tax']['origin'] = array(
    '#type' => 'fieldset',
    '#title' => t('Shipping origin address'),
  );
  $form['tax']['origin']['city'] = array(
    '#type' => 'textfield',
    '#title' => t('City'),
    '#default_value' => $settings['tax']['origin']['city'],
    '#maxlength' => 50,
  );
  $form['tax']['origin']['state'] = array(
    '#type' => 'textfield',
    '#title' => t('State / Province'),
    '#description' => t('Use the appropriate two-letter abbreviation.'),
    '#default_value' => $settings['tax']['origin']['state'],
    '#maxlength' => 2,
  );
  $form['tax']['origin']['postal_code'] = array(
    '#type' => 'textfield',
    '#title' => t('Postal code'),
    '#default_value' => $settings['tax']['origin']['postal_code'],
    '#maxlength' => 10,
  );
  $form['tax']['origin']['county'] = array(
    '#type' => 'textfield',
    '#title' => t('County'),
    '#default_value' => $settings['tax']['origin']['county'],
    '#maxlength' => 50,
  );
  $form['tax']['origin']['country'] = array(
    '#type' => 'select',
    '#title' => t('Country'),
    '#options' => country_get_list(),
    '#default_value' => $settings['tax']['origin']['country'],
  );

  $form['tax']['seller_registration'] = array(
    '#type' => 'textarea',
    '#title' => t('VAT seller registration number(s)'),
    '#description' => t('Enter a comma-separated list of your VAT seller registration numbers.'),
  );

  return $form;
}

/**
 * Payment method callback: checkout form.
 */
function commerce_cybersource_soap_cc_submit_form($payment_method, $pane_values, $checkout_pane, $order) {
  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');
  $payment_method['settings'] += commerce_cybersource_soap_cc_default_settings();

  // Prepare the fields to include on the credit card form.
  $fields = array(
    'code' => '',
  );

  // Add the credit card types array if necessary.
  $card_types = array_diff(array_values($payment_method['settings']['credit_card']['card_types']), array(0));

  if (!empty($card_types)) {
    $fields['type'] = $card_types;
  }

  return commerce_payment_credit_card_form($fields);
}

/**
 * Payment method callback: checkout form validation.
 */
function commerce_cybersource_soap_cc_submit_form_validate($payment_method, $pane_form, $pane_values, $order, $form_parents = array()) {
  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');

  // Validate the credit card fields.
  $settings = array(
    'form_parents' => array_merge($form_parents, array('credit_card')),
  );

  if (!commerce_payment_credit_card_validate($pane_values['credit_card'], $settings)) {
    return FALSE;
  }
}

/**
 * Payment method callback: checkout form submission.
 */
function commerce_cybersource_soap_cc_submit_form_submit($payment_method, $pane_form, $pane_values, $order, $charge) {
  $payment_method['settings'] += commerce_cybersource_soap_cc_default_settings();

  // Create and populate the request object.
  $request = (object) array(
    'merchantReferenceCode' => t('Order @number', array('@number' => $order->order_number)),
  );

  // Request an authorization that may also be captured this request. Whether
  // the default transaction type is authorization only or authorization plus
  // capture, the authorization must first happen in its own API request.
  $request->ccAuthService = (object) array(
    'run' => 'true',
  );

  // Add the billing information.
  $request->billTo = commerce_cybersource_address('billing', $order, 'commerce_customer_billing');

  // Add the credit card details.
  $request->card = (object) array(
    'accountNumber' => $pane_values['credit_card']['number'],
    'expirationMonth' => $pane_values['credit_card']['exp_month'],
    'expirationYear' => $pane_values['credit_card']['exp_year'],
  );

  // Add the CVV data if included.
  if (isset($pane_values['credit_card']['code'])) {
    $request->card->cvNumber = $pane_values['credit_card']['code'];
  }

  // Add purchase total information.
  $request->purchaseTotals = (object) array(
    'currency' => $charge['currency_code'],
    'grandTotalAmount' => commerce_currency_amount_to_decimal($charge['amount'], $charge['currency_code']),
  );

  // Individually add each line item to the order if specified. In the event
  // that the total value of all the line items and their taxes does not match
  // the grandTotalAmount supplied above, the itemization will be ignored and
  // CyberSource will process the transaction based solely on that amount.
  if ($payment_method['settings']['credit_card']['submit_itemized_order']) {
    $items = commerce_cybersource_itemize_order($order, $charge['currency_code']);

    if (!empty($items)) {
      $request->item = $items;
    }
  }

  // Add the capture directive if specified in the payment method settings.
  if ($payment_method['settings']['credit_card']['transaction_type'] == COMMERCE_CREDIT_AUTH_CAPTURE) {
    $request->ccCaptureService = (object) array(
      'run' => 'true',
    );
  }

  if ($response = commerce_cybersource_soap_api_request($payment_method, $request)) {
    // Prepare a transaction object to log the API response.
    $transaction = commerce_payment_transaction_new('cybersource_soap_cc', $order->order_id);
    $transaction->instance_id = $payment_method['instance_id'];
    $transaction->remote_id = $response->requestID;
    $transaction->amount = $charge['amount'];
    $transaction->currency_code = $charge['currency_code'];
    $transaction->payload[REQUEST_TIME] = $response;

    // If we didn't get an approval response code...
    if ($response->ccAuthReply->reasonCode != 100) {
      // Create a failed transaction with the error message.
      $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
    }
    else {
      // Otherwise if we also captured successfully, mark this as a success.
      if ($payment_method['settings']['credit_card']['transaction_type'] == COMMERCE_CREDIT_AUTH_CAPTURE &&
        $response->ccCaptureReply->reasonCode == 100) {
        $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
        $transaction->remote_status = COMMERCE_CREDIT_AUTH_CAPTURE;
      }
      else {
        // Or leave it pending.
        $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;

        // Store the transaction type with the timestamp so the request token can be
        // reliably retrieved later for capturing.
        $transaction->remote_status = COMMERCE_CREDIT_AUTH_ONLY . ':' . REQUEST_TIME;
      }
    }

    // Build a meaningful response message.
    $message = array(
      '<b>' . ($payment_method['settings']['credit_card']['transaction_type'] == COMMERCE_CREDIT_AUTH_ONLY ? t('Credit Card Authorization') : t('Credit Card Authorization and Capture')) . '</b>',
      '<b>' . t('@decision:', array('@decision' => $response->decision)) . '</b> ' . commerce_cybersource_reason_message($response->reasonCode),
    );

    // Add an AVS response if returned.
    if (!empty($response->ccAuthReply->avsCode)) {
      $message[] = '<b>' . t('AVS response:') . '</b> ' . commerce_cybersource_avs_response($response->ccAuthReply->avsCode);
    }

    // Add a CVV response if returned.
    if (!empty($response->ccAuthReply->cvCode)) {
      $message[] = '<b>' . t('CVN response:') . '</b> ' . commerce_cybersource_avs_response($response->ccAuthReply->cvCode);
    }

    $transaction->message = implode('<br />', $message);

    // Save the transaction information.
    commerce_payment_transaction_save($transaction);

    // If the payment failed, display an error and rebuild the form.
    if ($response->ccAuthReply->reasonCode != 100) {
      drupal_set_message(t('We received the following error processing your card: @reason', array('@reason' => commerce_cybersource_reason_message($response->ccAuthReply->reasonCode))), 'error');
      drupal_set_message('Please enter you information again or try a different card.', 'error');
      return FALSE;
    }
  }
  else {
    drupal_set_message(t('We encountered an error contacting our payment processor. Please try submitting your payment again.'), 'error');
    return FALSE;
  }
}

/**
 * Returns an address object for use in a CyberSource API request.
 *
 * @param $type
 *   The type of address object to return, either 'billing' or 'shipping'.
 *   Billing addresses include an e-mail address and IP address in addition to
 *   the actual billing address.
 * @param $order
 *   The order object containing the address information via a referenced
 *   customer profile.
 * @param $field_name
 *   The name of the customer profile reference field that links the order to
 *   the proper customer profile where the address data will be retrieved from.
 *
 * @return
 *   An object representing the address of the requested type for use in a
 *   CyberSource API request.
 */
function commerce_cybersource_address($type, $order, $field_name) {
  // Return an empty address object if the specified profile field doesn't exist.
  if (empty($order->{$field_name})) {
    return new stdClass();
  }

  // Prepare the address data for use in the request address.
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $address_data = $order_wrapper->{$field_name}->commerce_customer_address->value();

  if (empty($address_data['first_name'])) {
    $name_parts = explode(' ', $address_data['name_line']);
    $address_data['first_name'] = array_shift($name_parts);
    $address_data['last_name'] = implode(' ', $name_parts);
  }

  // Add the basic address information to the return array.
  $address = array(
    'firstName' => $address_data['first_name'],
    'lastName' => $address_data['last_name'],
    'street1' => $address_data['thoroughfare'],
    'street2' => $address_data['premise'],
    'city' => $address_data['locality'],
    'state' => $address_data['administrative_area'],
    'postalCode' => $address_data['postal_code'],
    'country' => $address_data['country'],
  );

  // Add the e-mail and IP address to the billing information.
  if ($type == 'billing') {
    $address += array(
      'email' => empty($order->mail) ? 'null@cybersource.com' : $order->mail,
      'ipAddress' => ip_address(),
    );
  }

  return (object) $address;
}

/**
 * Returns an array of items as expected by the CyberSource API representing the
 * line items on the order.
 *
 * @param $order
 *   The order to itemize.
 * @param $currency_code
 *   The currency code of the currency when calculating the unit price of all
 *   the items and taxes derived from the order's line items.
 * @param $include_tax
 *   Boolean indicating whether or not to include tax amounts on items if available.
 *
 * @return
 *   An array of items as expected by the CyberSource API.
 */
function commerce_cybersource_itemize_order($order, $currency_code, $include_tax = TRUE) {
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $items = array();

  // Loop over each line item on the order.
  foreach ($order_wrapper->commerce_line_items as $delta => $line_item_wrapper) {
    $item = new stdClass();
    $item->id = $line_item_wrapper->line_item_id->value();

    // See Appendix F in the Simple Order API documentation for a list of
    // available product codes. These don't necessarily pertain just to
    // physical or electronic products.
    $item->productCode = 'default';

    // Add product data if this is a product line item.
    if (in_array($line_item_wrapper->type->value(), commerce_product_line_item_types())) {
      $item->productName = $line_item_wrapper->commerce_product->title->value();
      $item->productSKU = $line_item_wrapper->commerce_product->sku->value();
    }
    else {
      $item->productName = $line_item_wrapper->description->value();
      $item->productSKU = $line_item_wrapper->label->value();
    }

    // The unit price is assumed to be in the currency used in the purchase
    // total information above.
    $item_amount = $line_item_wrapper->commerce_unit_price->amount->value();
    $item_currency_code = $line_item_wrapper->commerce_unit_price->currency_code->value();

    $item->unitPrice = commerce_currency_amount_to_decimal(commerce_currency_convert($item_amount, $item_currency_code, $currency_code), $currency_code);
    $item->quantity = $line_item_wrapper->quantity->value();

    // Conditionally add any non-inclusive tax included in the line item.
    if ($include_tax && module_exists('commerce_tax')) {
      $data = $line_item_wrapper->commerce_unit_price->data->value();
      $amount = commerce_tax_total_amount($data['components'], FALSE, $currency_code) * $line_item_wrapper->quantity->value();

      $item->taxAmount = commerce_currency_amount_to_decimal($amount, $currency_code);;
    }

    // Give other modules a chance to alter the item before adding it.
    drupal_alter('commerce_cybersource_item', $item, $line_item_wrapper->value());

    // Add the item to the return value.
    $items[] = $item;
  }

  return $items;
}

/**
 * Submits a prior authorization capture request.
 *
 * @param $order
 *   The order object the payment is for.
 * @param $transaction
 *   The payment transaction representing the authorization the capture is for.
 * @param $amount
 *   An integer price amount.
 *
 * @return
 *   The response from CyberSource or FALSE upon failure.
 */
function commerce_cybersource_soap_capture($order, $transaction, $amount) {
  // Load the payment method instance used to create the authorization.
  $payment_method = commerce_payment_method_instance_load($transaction->instance_id);

  // Extract the timestamp used to retrieve the order request token from the
  // remote status value.
  list($status, $timestamp) = explode(':', $transaction->remote_status);

  // Fail now if now timestamp was found or the payload is missing.
  if (empty($timestamp) || empty($transaction->payload[$timestamp])) {
    return FALSE;
  }

  // Create and populate the request object.
  $request = (object) array(
    'merchantReferenceCode' => t('Order @number', array('@number' => $order->order_number)),
    'orderRequestToken' => $transaction->payload[$timestamp]->requestToken,
  );

  // Add purchase total information.
  $request->purchaseTotals = (object) array(
    'currency' => $transaction->currency_code,
    'grandTotalAmount' => commerce_currency_amount_to_decimal($amount, $transaction->currency_code),
  );

  // Add the capture service information.
  $request->ccCaptureService = (object) array(
    'run' => 'true',
    'authRequestID' => $transaction->remote_id,
  );

  if ($response = commerce_cybersource_soap_api_request($payment_method, $request)) {
    // Add the response to the payload.
    $transaction->payload[REQUEST_TIME] = $response;

    if ($response->ccCaptureReply->reasonCode == 100) {
      // Update the amount in case it changed between authorization and capture.
      $transaction->amount = commerce_currency_decimal_to_amount($response->ccCaptureReply->amount, $transaction->currency_code);

      // Update the transaction status and remote status.
      $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
      $transaction->remote_status = COMMERCE_CREDIT_PRIOR_AUTH_CAPTURE . ':' . REQUEST_TIME;
    }

    commerce_payment_transaction_save($transaction);

    return $response;
  }
  else {
    return FALSE;
  }
}

/**
 * Submits a tax calculation request.
 *
 * @param $payment_method
 *   The payment method instance array associated with this API request.
 * @param $order
 *   The order object whose taxes should be calculated.
 *
 * @return
 *   The tax response from CyberSource or FALSE upon failure.
 */
function commerce_cybersource_soap_calculate_taxes($payment_method, $order) {
  $payment_method['settings'] += commerce_cybersource_soap_cc_default_settings();
  $tax_settings = $payment_method['settings']['tax'];

  // If tax calculation isn't enabled, return FALSE.
  if (!$tax_settings['calculate_taxes']) {
    return FALSE;
  }

  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  // Create and populate the request object.
  $request = (object) array(
    'merchantReferenceCode' => t('Order @number', array('@number' => $order->order_number)),
  );

  // Request tax calculation.
  $request->taxService = (object) array(
    'run' => 'true',

    'orderOriginCity' => $tax_settings['poo']['city'],
    'orderOriginState' => $tax_settings['poo']['state'],
    'orderOriginPostalCode' => $tax_settings['poo']['postal_code'],
    'orderOriginCounty' => $tax_settings['poo']['county'],
    'orderOriginCountry' => $tax_settings['poo']['country'],

    'orderAcceptanceCity' => $tax_settings['poa']['city'],
    'orderAcceptanceState' => $tax_settings['poa']['state'],
    'orderAcceptancePostalCode' => $tax_settings['poa']['postal_code'],
    'orderAcceptanceCounty' => $tax_settings['poa']['county'],
    'orderAcceptanceCountry' => $tax_settings['poa']['country'],
  );

  // Only add the nexus property if it has been entered.
  if (!empty($tax_settings['nexus'])) {
    $request->taxService->nexus = $tax_settings['nexus'];
  }

  // Only add VAT seller registration numbers if they have been specified.
  if (!empty($tax_settings['seller_registration'])) {
    $vat_numbers = explode(',', $tax_settings['seller_registration']);

    // If there is only one VAT number entered...
    if (count($vat_numbers) == 1) {
      // Add it as the sole VAT seller registration number.
      $request->taxService->sellerRegistration = trim($vat_numbers[0]);
    }
    else {
      // Otherwise loop over all entered numbers and add them.
      foreach ($vat_numbers as $delta => $vat_number) {
        $request->taxService->{'sellerRegistration' . $delta} = trim($vat_number);
      }
    }
  }

  // TODO: Add support for the customer's VAT registration number.

  // Add an origin address for shipped items.
  $request->shipFrom = (object) array(
    'city' => $tax_settings['origin']['city'],
    'state' => $tax_settings['origin']['state'],
    'postalCode' => $tax_settings['origin']['postal_code'],
    'county' => $tax_settings['origin']['county'],
    'country' => $tax_settings['origin']['country'],
  );

  // Add the customer's billing information.
  $request->billTo = commerce_cybersource_address('billing', $order, 'commerce_customer_billing');

  // Add the customer's shipping information.
  if (!empty($tax_settings['shipping_profile'])) {
    $request->shipTo = commerce_cybersource_address('shipping', $order, $tax_settings['shipping_profile']);
  }

  // Add purchase total information.
  $currency_code = $order_wrapper->commerce_order_total->currency_code->value();

  $request->purchaseTotals = (object) array(
    'currency' => $currency_code,
  );

  // Itemize the line items on the order.
  $items = commerce_cybersource_itemize_order($order, $currency_code, FALSE);

  if (!empty($items)) {
    $request->item = $items;
  }

  if ($response = commerce_cybersource_soap_api_request($payment_method, $request)) {
    return $response;
  }
  else {
    return FALSE;
  }
}

/**
 * Submits an API request through the CyberSource SOAP API Toolkit.
 *
 * @param $payment_method
 *   The payment method instance array associated with this API request.
 * @param $request
 *   The request object containing the parameters of the requested services.
 *
 * @return
 *   The response object from the API with properties pertinent to the requested
 *     services.
 */
function commerce_cybersource_soap_api_request($payment_method, $request) {
  // Get the API endpoint URL for the method's transaction mode.
  $url = commerce_cybersource_soap_wsdl_url($payment_method['settings']['transaction_mode']);

  // Add the merchant ID to the request object.
	$request->merchantID = $payment_method['settings']['merchant_id'];

  // Add information on PHP for troubleshooting purposes.
	$request->clientLibrary = 'PHP';
  $request->clientLibraryVersion = phpversion();
  $request->clientEnvironment = php_uname();

  // Log the request if specified.
  if ($payment_method['settings']['log']['request'] == 'request') {
    // Get our clone on to avoid messing up the legit data.
    $log_request = clone($request);

    // Mask the credit card number and CVV.
    if (!empty($log_request->card)) {
      $log_request->card = clone($log_request->card);

      $log_request->card->accountNumber = str_repeat('X', strlen($log_request->card->accountNumber) - 4) . substr($log_request->card->accountNumber, -4);

      if (!empty($log_request->card->cavv)) {
        $log_request->card->cavv = str_repeat('X', strlen($log_request->card->cavv));
      }
    }

    watchdog('commerce_cybersource', 'CyberSource SOAP request to @url: !request', array('@url' => $url, '!request' => '<pre>' . check_plain(print_r($log_request, TRUE)) . '</pre>'), WATCHDOG_DEBUG);
  }

  // Attempt the SOAP request and log the exception on failure.
  try {
    $soapClient = new CommerceCyberSourceSoapClient($url, array(), $request->merchantID, $payment_method['settings']['transaction_key']);
    $response = $soapClient->runTransaction($request);
  }
  catch (SoapFault $exception) {
    watchdog('commerce_cybersource', 'SoapFault: !exception', array('!exception' => '<pre>' . print_r($exception, TRUE) . '</pre>'), WATCHDOG_ERROR);
    return FALSE;
  }

  // Log the response if specified.
  if ($payment_method['settings']['log']['response'] == 'response') {
    watchdog('commerce_cybersource', 'CyberSource SOAP response: !request', array('!request' => '<pre>' . check_plain(print_r($response, TRUE)) . '</pre>', WATCHDOG_DEBUG));
  }

  return $response;
}

/**
 * Returns the URL to the CyberSource WSDL determined by transaction mode.
 *
 * @param $transaction_mode
 *   The transaction mode that relates to the production or test server.
 *
 * @return
 *   The URL to use to submit requests to the CyberSource SOAP server.
 */
function commerce_cybersource_soap_wsdl_url($transaction_mode) {
  switch ($transaction_mode) {
    case CYBERSOURCE_TXN_MODE_PRODUCTION:
      return 'https://ics2ws.ic3.com/commerce/1.x/transactionProcessor/CyberSourceTransaction_1.55.wsdl';
    case CYBERSOURCE_TXN_MODE_TEST:
      return 'https://ics2wstest.ic3.com/commerce/1.x/transactionProcessor/CyberSourceTransaction_1.55.wsdl';
  }
}

/**
 * Returns the message text for a credit card service reason code.
 */
function commerce_cybersource_reason_message($code) {
  switch ($code) {
    case 100:
      return t('Successful transaction.');
    case 101:
      return t('The request is missing one or more required fields.');
    case 102:
      return t('One or more fields in the request contains invalid data.');
    case 110:
      return t('Only a partial amount was approved.');
    case 150:
      return t('Error: General system failure.');
    case 151:
      return t('Error: The request was received but there was a server timeout. This error does not include timeouts between the client and the server.');
    case 152:
      return t('Error: The request was received, but a service did not finish running in time.');
    case 200:
      return t('The authorization request was approved by the issuing bank but declined by CyberSource because it did not pass the Address Verification Service (AVS) check.');
    case 201:
      return t('The issuing bank has questions about the request. You do not receive an authorization code programmatically, but you might receive one verbally by calling the processor.');
    case 202:
      return t('Expired card.');
    case 203:
      return t('General decline of the card. No other information provided by the issuing bank.');
    case 204:
      return t('Insufficient funds in the account.');
    case 205:
      return t('Stolen or lost card.');
    case 207:
      return t('Issuing bank unavailable.');
    case 208:
      return t('Inactive card or card not authorized for card-not-present transactions.');
    case 209:
      return t('American Express Card Identification Digits (CID) did not match.');
    case 210:
      return t('The card has reached the credit limit.');
    case 211:
      return t('Invalid CVN.');
    case 221:
      return t('The customer matched an entry on the processor’s negative file.');
    case 230:
      return t('The authorization request was approved by the issuing bank but declined by CyberSource because it did not pass the CVN check.');
    case 231:
      return t('Invalid account number.');
    case 232:
      return t('The card type is not accepted by the payment processor.');
    case 233:
      return t('General decline by the processor.');
    case 234:
      return t('There is a problem with your CyberSource merchant configuration.');
    case 235:
      return t('The requested amount exceeds the originally authorized amount.');
    case 236:
      return t('Processor failure.');
    case 237:
      return t('The authorization has already been reversed.');
    case 238:
      return t('The authorization has already been captured.');
    case 239:
      return t('The requested transaction amount must match the previous transaction amount.');
    case 240:
      return t('The card type sent is invalid or does not correlate with the credit card number.');
    case 241:
      return t('The request ID is invalid.');
    case 242:
      return t('You requested a capture, but there is no corresponding, unused authorization record.');
    case 243:
      return t('The transaction has already been settled or reversed.');
    case 246:
      return t('The capture or credit is not voidable because the capture or credit information has already been submitted to your processor or you requested a void for a type of transaction that cannot be voided.');
    case 247:
      return t('You requested a credit for a capture that was previously voided.');
    case 250:
      return t('Error: The request was received, but there was a timeout at the payment processor.');
  }

  return '-';
}

/**
 * Returns the message text for an AVS response code.
 */
function commerce_cybersource_avs_response($code) {
  switch ($code) {
    case'A':
      return t('Partial match: Street address matches, but 5-digit and 9-digit postal codes do not match.');
    case 'B':
      return t('Partial match: Street address matches, but postal code is not verified.');
    case 'C':
      return t('No match: Street address and postal code do not match.');
    case 'D':
    case 'M':
      return t('Match: Street address and postal code match.');
    case 'E':
      return t('Invalid: AVS data is invalid or AVS is not allowed for this card type.');
    case 'F':
      return t("Partial match: Card member's name does not match, but billing postal code matches.");
    case 'G':
      return t('Not supported: Non-U.S. issuing bank does not support AVS.');
    case 'H':
      return t('Partial match: Card member’s name does not match, but street address and postal code match.');
    case 'I':
      return t('No match: Address not verified.');
    case 'K':
      return t("Partial match: Card member's name matches, but billing address and billing postal code do not match.");
    case 'L':
      return t("Partial match: Card member's name and billing postal code match, but billing address does not match.");
    case 'N':
      return t("No match: Street address and postal code do not match or card member's name, street address and postal code do not match.");
    case 'O':
      return t("Partial match: Card member's name and billing address match, but billing postal code does not match.");
    case 'P':
      return t('Partial match: Postal code matches, but street address not verified.');
    case 'R':
      return t('System unavailable.');
    case 'S':
      return t('Not supported: U.S.-issuing bank does not support AVS.');
    case 'T':
      return t("Partial match: Card member's name does not match, but street address matches.");
    case 'U':
      return t('System unavailable: Address information unavailable from the bank.');
    case 'V':
      return t("Match: Card member's name, billing address, and billing postal code match.");
    case 'W':
      return t('Partial match: Street address does not match, but 9-digit postal code matches.');
    case 'X':
      return t('Match: Street address and 9-digit postal code match.');
    case 'Y':
      return t('Match: Street address and 5-digit postal code match.');
    case 'Z':
      return t('Partial match: Street address does not match, but 5-digit postal code matches.');
    case '1':
      return t('Not supported: AVS is not supported for this processor or card type.');
    case '2':
      return t('Invalid: The processor returned an unrecognized value for the AVS response.');
  }

  return '-';
}

/**
 * Returns the message text for a CVV match.
 */
function commerce_cybersource_cvn_response($code) {
  switch ($code) {
    case 'D':
      return t('The transaction was determined to be suspicious by the issuing bank.');
    case 'I':
      return t("The CVN failed the processor's data validation check.");
    case 'M':
      return t('The CVN matched.');
    case 'N':
      return t('The CVN did not match.');
    case 'P':
      return t('The CVN was not processed by the processor for an unspecified reason.');
    case 'S':
      return t('The CVN is on the card but was not included in the request.');
    case 'U':
      return t('Card verification is not supported by the issuing bank.');
    case 'X':
      return t('Card verification is not supported by the card association.');
    case '1':
      return t('Card verification is not supported for this processor or card type.');
    case '2':
      return t('An unrecognized result code was returned by the processor for the card verification response.');
    case '3':
      return t('No result code was returned by the processor.');
  }

  return '-';
}
